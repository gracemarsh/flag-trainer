# Data Models

This document outlines the data models for the Flag Trainer application. We'll be using Turso (SQLite) with Drizzle ORM for user session tracking, while flag data will be stored statically in the application code.

## Core Entities

### Flags (Static Application Data)

Flags are now stored as static JSON data in the application code rather than in the database. This approach reduces database requests and improves performance.

```typescript
// src/data/flags.ts
export interface Flag {
  id: number;
  name: string; // Country name
  code: string; // ISO country code (e.g., US, FR)
  continent: string; // Continent/region
  population?: number;
  languages?: string; // Comma-separated list of languages
  funFacts?: string; // JSON string of fun facts (parsed/stringified in application)
  difficulty?: number; // Recognizability score (1-10, 10 being hardest)
  imageUrl: string; // Path to flag image
}

export const flags: Flag[] = [
  // Static array of flag data
  // Loaded at build time, no database queries required
];
```

### Users

```typescript
export const users = sqliteTable("users", {
  id: text("id").primaryKey(), // UUID generated by auth system
  name: text("name"),
  email: text("email").notNull().unique(),
  emailVerified: integer("email_verified", { mode: "timestamp_ms" }),
  image: text("image"), // Profile picture URL
  createdAt: integer("created_at", { mode: "timestamp_ms" }).defaultNow(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" }).defaultNow(),
});
```

### User Progress (For Spaced Repetition)

```typescript
export const userProgress = sqliteTable("user_progress", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  flagCode: text("flag_code").notNull(), // ISO country code instead of foreign key
  correctCount: integer("correct_count").default(0), // Number of times answered correctly
  incorrectCount: integer("incorrect_count").default(0), // Number of times answered incorrectly
  lastSeen: integer("last_seen", { mode: "timestamp_ms" }), // When the flag was last shown to user
  nextReviewDate: integer("next_review_date", { mode: "timestamp_ms" }), // When to show this flag again
  easeFactor: real("ease_factor").default(2.5), // For spaced repetition algorithm
  interval: integer("interval").default(1), // Current interval in days
});
```

### Competition Scores

```typescript
export const scores = sqliteTable("scores", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id").references(() => users.id, { onDelete: "cascade" }),
  guestId: text("guest_id"), // For guest users (stored in local storage)
  score: integer("score").notNull(), // Total score
  difficulty: text("difficulty").notNull(), // 'beginner', 'intermediate', 'expert'
  streak: integer("streak").notNull(), // Highest consecutive correct answers
  accuracy: real("accuracy").notNull(), // Percentage correct
  totalAnswered: integer("total_answered").notNull(), // Total flags attempted
  timeSpent: integer("time_spent"), // Time in seconds
  createdAt: integer("created_at", { mode: "timestamp_ms" }).defaultNow(),
});
```

### User Settings

```typescript
export const userSettings = sqliteTable("user_settings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  userId: text("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),
  darkMode: integer("dark_mode", { mode: "boolean" }).default(0), // SQLite doesn't have boolean
  soundEnabled: integer("sound_enabled", { mode: "boolean" }).default(1),
  preferredDifficulty: text("preferred_difficulty").default("beginner"),
  flagsPerSession: integer("flags_per_session").default(10),
  createdAt: integer("created_at", { mode: "timestamp_ms" }).defaultNow(),
  updatedAt: integer("updated_at", { mode: "timestamp_ms" }).defaultNow(),
});
```

## Relationships

- **User** → **UserProgress**: One-to-many (a user has progress records for many flags)
- **User** → **Scores**: One-to-many (a user has many competition scores)
- **User** → **UserSettings**: One-to-one (a user has one settings record)

## Indexes

```typescript
// For efficient querying of a user's progress
export const userProgressIndex = index("user_progress_user_id_idx").on(
  userProgress.userId,
);
export const userProgressFlagCodeIndex = index(
  "user_progress_flag_code_idx",
).on(userProgress.flagCode);

// For finding flags due for review (spaced repetition algorithm)
export const nextReviewIndex = index("user_progress_next_review_date_idx").on(
  userProgress.nextReviewDate,
);

// For efficient leaderboard queries
export const scoresIndex = index("scores_score_idx").on(scores.score);
export const scoresDifficultyIndex = index("scores_difficulty_idx").on(
  scores.difficulty,
);
```

## Static Flag Data Management

### Loading Flags

Flag data is loaded when the application starts:

```typescript
// src/lib/flags.ts
import { flags } from "@/data/flags";

// Helper functions for flag operations
export function getFlagByCode(code: string): Flag | undefined {
  return flags.find((flag) => flag.code === code);
}

export function getFlagsByContinent(continent: string): Flag[] {
  return flags.filter((flag) => flag.continent === continent);
}

export function getRandomFlags(count: number): Flag[] {
  // Shuffle and return a random subset of flags
  return [...flags].sort(() => Math.random() - 0.5).slice(0, count);
}
```

### Continent/Region Filtering

```typescript
export const continents = [
  "Africa",
  "Asia",
  "Europe",
  "North America",
  "Oceania",
  "South America",
];

export function getFlagsByContinent(continent: string): Flag[] {
  return flags.filter((flag) => flag.continent === continent);
}
```

## Local Storage Schema (for Guest Mode)

For users who haven't created an account, we'll store a simplified version of their progress in localStorage:

```typescript
interface GuestProgress {
  guestId: string; // Random UUID generated on first visit
  flagProgress: {
    [flagCode: string]: {
      // ISO country code as key
      correctCount: number;
      incorrectCount: number;
      lastSeen: string; // ISO date string
      nextReviewDate: string; // ISO date string
      easeFactor: number;
    };
  };
  competitionScores: {
    id: string; // Random UUID for each score entry
    score: number;
    difficulty: string;
    streak: number;
    accuracy: number;
    totalAnswered: number;
    timeSpent: number;
    createdAt: string; // ISO date string
  }[];
  settings: {
    darkMode: boolean;
    soundEnabled: boolean;
    preferredDifficulty: string;
    flagsPerSession: number;
  };
}
```
